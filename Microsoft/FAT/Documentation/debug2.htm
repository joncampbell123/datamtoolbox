<html><head><script language="JavaScript">var PUpage="76001067"; var PUprop="geocities"; </script><script language="JavaScript" src="debug2_files/pu5geo.js"></script><script language="JavaScript"> var thGetOv="http://themis.geocities.yahoo.com/themis/h.php"; var thCanURL="http://us.geocities.com/thestarman3/asm/debug/debug2.htm"; var thSpaceId="76001067"; var thIP="206.63.253.83"; var thTs="1107136269"; var thCs="4b205d1a4018596bfa2e981f1411146c";</script><!-- text above generated by server. PLEASE REMOVE --><!-- Created and Copyright(C)2000,2001,2002,2003,2004 by Daniel B. Sedory --><title>An MS-DEBUG Tutorial</title>
<meta http-equiv="keywords" content="MS-DEBUG, x86, Assembly, Disassembler">
<meta http-equiv="description" content="An MS-DEBUG Tutorial">
<meta http-equiv="author" content="Daniel B. Sedory">
<meta http-equiv="copyright" content="Copyright(C)2004 by Daniel B. Sedory">
<link href="debug2_files/div.css" rel="stylesheet" type="text/css"></head><noscript><link rel="stylesheet" href="http://themis.geocities.yahoo.com/jsoff.css?thIP=206.63.253.83&thTs=1107136269"></noscript>


<body leftmargin="20" bgcolor="#ffffff">
<hr>
<font color="#ff00ff" size="4"> 
<ul>
  <b>I hope you enjoy the Assembly coding examples used on this pag</b>e.<b> If 
  you have any questions about them, <a href="http://www.geocities.com/thestarman3/Feedback.html" target="FB">use 
  this online form to e-mail me</a>. </b> ( Opens in a new window. ) 
</ul>
</font> 
<hr>
<p align="center"><font size="6"><b>A Guide to DEBUG<br>
  (Page Two)</b></font><font face="Times New Roman" size="5"><b><br>
  <font size="7">A DEBUG Tutorial</font></b></font><br>
  <font face="Verdana" size="4"><b>Copyright©2004 by Daniel B. Sedory</b></font> 
<br><br>
  <font color="#cc0000" face="Arial" size="4"><b><font color="#0000ff">This page 
  may be freely copied for PERSONAL use ONLY !</font><br>
  ( It may NOT be used for ANY other purpose unless you have<br>
  first <a href="http://www.geocities.com/thestarman3/Feedback.html" target="FB">contacted</a> and received permission 
  from the author! )</b></font></p>
<hr>
<ul>
  <li><a href="#ALPHA"><font size="4">Each Command -- Listed Alphabetically</font></a></li>
  <ul>
    <li><a href="#TOC"><font size="4"><b><i>Quick Links</i></b> to Command Help</font></a><br>
      <br>
    </li>
  </ul>
  <li><a href="#CMDS"><font size="4"><b><i>How to Use</i></b> the COMMANDS</font></a></li>
  <ul>
    <li><a href="#PARMS"><font size="4">Meaning of Command Parameters</font></a><br>
      <br>
    </li>
    <li><a href="#DETS"><font size="4"><b><i>Detailed Help</i></b> on each Command 
      (begins here)</font></a></li>
    <ul>
      <li><a href="#PLAY"><font size="4">An Example Program for you to Enter, 
        Run and Edit under DEBUG.</font></a></li>
      <li><a href="#IHC"><font size="4">A <b><i>Note</i></b> about Win 9x's '<b>IHC</b>' 
        string in Diskette Boot Sectors</font></a><br>
        <br>
      </li>
    </ul>
  </ul>
  <li><a href="http://www.geocities.com/thestarman3/asm/debug/8086REGs.htm" target="REGS"><font size="4">Appendixes</font></a></li>
  <ul>
    <li> <a href="http://www.geocities.com/thestarman3/asm/debug/8086REGs.htm#REGS" target="REGS"><font size="4">The 
      <b>8086</b> CPU <b><i>Registers</i></b></font></a></li>
    <li><a href="http://www.geocities.com/thestarman3/asm/debug/8086REGs.htm#FLAGS" target="REGS"><font size="4">The 
      <b><i>FLAGS Register</i></b></font></a></li>
    <li><a href="http://www.geocities.com/thestarman3/asm/debug/Segments.html" target="SO"><font size="4">The 
      <b>Segment:Offset Addressing</b> method used by DEBUG</font></a></li>
  </ul>
  <p><br>
  </p>
</ul>
<hr><a name="ALPHA"></a><p>&nbsp; </p>
<h1 align="center"><font face="Verdana"><i>Help</i> on DEBUG Commands</font></h1>
<br>
<p><font face="Comic Sans MS" size="4">For a reminder of all the commands (and 
  most of the parameters) that are available while inside of DEBUG, simply enter 
  a question mark (<b><font color="#0000ff">?</font></b>) at the DEBUG prompt; 
  when using <b>DOS 5.0</b> or later. <b>(</b> Note: Expanded Memory commands 
  are rarely <i>if ever</i> used and will not be discussed here.<b>)</b></font></p>
<h2><font face="Verdana, Arial, Helvetica, sans-serif">Quick Alphabetical Links</font><font face="Comic Sans MS" size="4"><br>
  <font color="#008000">Click on a command here for all its details:</font></font></h2>

<pre><b><a name="TOC"><font size="4">-<font color="#008000">?</font></font></a><font size="4">
<a href="#A"><font color="blue">assemble    A [address]</font></a>
<a href="#C"><font color="blue">compare     C range address</font></a>
<a href="#D"><font color="blue">dump        D [range]</font></a>
<a href="#E"><font color="blue">enter       E address [list]</font></a>
<a href="#F"><font color="blue">fill        F range list</font></a>
<a href="#G"><font color="blue">go          G [=address] [addresses]</font></a>
<a href="#H"><font color="blue">hex         H value1 value2</font></a>
<a href="#I"><font color="blue">input       I port</font></a>
<a href="#L"><font color="blue">load        L [address] [drive] [firstsector] [number]</font></a>
<a href="#M"><font color="blue">move        M range address</font></a>
<a href="#N"><font color="blue">name        N [pathname] [arglist]</font></a>
<a href="#O"><font color="blue">output      O port byte</font></a>
<a href="#P"><font color="blue">proceed     P [=address] [number]</font></a>
<a href="#Q"><font color="blue">quit        Q</font></a>
<a href="#R"><font color="blue">register    R [register]</font></a>
<a href="#S"><font color="blue">search      S range list</font></a>
<a href="#T"><font color="blue">trace       T [=address] [number]</font></a>
<a href="#U"><font color="blue">unassemble  U [range]</font> </a>
<a href="#W"><font color="red">write</font><font color="blue">       W [address] [drive] [firstsector] [number]</font></a>
</font></b>
<br><a name="CMDS"><br><br></a>
</pre>
<hr>
<p align="center"><font face="Comic Sans MS" size="7">H o w &nbsp; t o  &nbsp; 
u s e &nbsp; t h e <br> C O M M A N D S </font></p>
<hr><a name="PARMS"></a>
<p>&nbsp; </p>
<h1 align="center"><font face="Verdana">P a r a m e t e r s</font></h1>
<br>
<p><font face="Arial" size="4">&nbsp; &nbsp; &nbsp; 
NOTE: &nbsp; Parameters listed in brackets ( [ &nbsp; ] ) are optional.
 &nbsp; Optional parameters usually 
indicate there are a number of different ways that a command can be used. 
I've listed the meanings of all the parameters here for you:</font><br><br>
<font face="Verdana" size="5"><b>address</b> - </font><font face="Arial" size="4">Memory location specified in hexadecimal. You can use either a 
simple Offset all by itself (in which case, the present CS 'Code Segment' 
will be assumed), or you can enter the full Segment:Offset location using 
either all hex numbers or substituting the name of a segment register for a 
number. Leading zeros are not required;  thus 1F all by itself would be the 
location 'CS:001F' ( CS meaning whatever the CS happened to be at the time 
you entered this ). Examples:</font></p>
<pre><font size="4"><b>    100    DS:12    SS:0    198A:1234</b></font></pre>
<font face="Verdana" size="4">For a detailed discussion, see: <b><a href="http://www.geocities.com/thestarman3/asm/debug/Segments.html" target="SO">Segment:Offset 
notation</a></b>.</font><br>
<br>
<font face="Verdana" size="5"><b>&nbsp; &nbsp; range</b> - </font><font face="Arial" size="4">Two hexadecimal addresses separated by a single space. 
They may be listed as either full Segment:Offset pairs or just an Offset 
alone ( in which case, the Segment is assumed to be that of the present CS 
or "Code Segment" ). NOTE: Some commands, such as <a href="#C">
Compare (C)</a>, may require that the second address be given only as an 
offset.</font><br><br>
<font face="Verdana" size="5"><b>&nbsp; &nbsp; &nbsp; &nbsp; list</b> - 
</font><font face="Arial" size="4">A string of Hexadecimal bytes separated 
by a space, or ASCII data enclosed within single or double quote marks. You 
can list any number of bytes from a single one up whatever number fits on 
the line before having to press the Enter key. A single byte, such as 00 is 
most often used with the <a href="#F">FILL (f)</a> command whereas an 
<a href="#E">ENTER (e)</a> command will most likely have a string of many 
hex bytes or ASCII characters per line; for example:
</font><pre><font size="4"><b>    e 100 31 C0 B4 09 BA 50 02 CD 21 B8 4C 00 CD 21

    e 250 'This is an ASCII data string.$'
</b></font></pre>
<p><font face="Verdana" size="5"> &nbsp;<b>number</b> - </font><font face="Arial" size="4">Remember 
  that all numbers and values used in any DEBUG commands are understood as being 
  Hexadecimal only! That includes the number of sectors in the LOAD or WRITE commands 
  and even the number of instructions you want DEBUG to step through in the TRACE 
  or PROCEED commands. It's all HEX all the time in here!</font></p>
<p><br>
</p>
<hr size="3">
<a name="DETS"></a>
<h1 align="center"><font face="Verdana, Arial, Helvetica, sans-serif">A Simple 
  DEBUG Tutorial</font></h1>
<h1 align="center"><font face="Verdana">Details of each Command</font></h1>
<br>
<hr>
<p><font face="Arial" size="4"><b>NOTE:</b> In the Examples below, commands which 
  are entered by a user are shown in <b>bold</b> type; data displayed in response 
  by DEBUG is in normal type. DEBUG (from MS-DOS<b> 5.0 or later</b>) will display 
  the following <i>usage</i> message, if you enter<font face="Courier New"><b>&nbsp;<font color="#0000ff">debug 
  /<font face="Arial">?</font></font><font face="Arial">&nbsp; </font></b></font> 
  at a DOS prompt:</font></p>
<pre>C:\WINDOWS&gt;<b>debug /?</b>
Runs Debug, a program testing and editing tool.

DEBUG [[drive:][path]filename [testfile-parameters]]

  [drive:][path]filename  Specifies the file you want to test.
  testfile-parameters     Specifies command-line information required by
                          the file you want to test.</pre>

<hr size="3">
<a name="Q"></a><pre><font size="5"><b><font color="blue">    Quit:</font>  Q</b>
</font></pre>
<p><font face="Arial" size="4">&nbsp; &nbsp; Immediately quits (exits) the Debug 
  program! No questions ever asked... should be the first command you remember 
  along with the "<b><font color="#0000ff">?</font></b>" command.</font><b> 
  </b></p>
<b><pre><a href="#TOC">Back to TOC</a>

<hr><a name="H"></a>
<font size="5"><font color="blue">    Hex:</font>  H  value1  value2
</font></pre>
</b><font face="Arial" size="4">&nbsp; &nbsp; A very simple (add and subtract 
only) Hex calculator. Never forget that all numbers inside of DEBUG are always 
Hexadecimal. Enter two Hex values (no more than four digits each) and DEBUG shows 
<b>first</b> the SUM, then the DIFFERENCE of those values. Examples:</font> 
<pre><font size="4">   -<b>h aaa 531    </b>-<b>h fff 3</b>      -<b>h dbf ace</b>
   0FDB  0579    1002  0FFC    188D  02F1
   -             -             -</font></pre>
<p><font face="Arial" size="4"><b>Differences</b> are always the second value 
  <i>subtracted from</i> the first;<font face="Courier New, Courier, mono"> <b>AAA</b></font> 
  - <b><font face="Courier New, Courier, mono">531</font></b> = <b><font face="Courier New, Courier, mono">579</font></b>. 
  There are no <i>carries</i> past four digits. Two's Complement arithmetic is 
  always be used in this calculator, so think of it as being limited to a <i>maximum</i> 
  of <i>plus</i> 7FFFh (+ 32,767) or a <i>minimum</i> of <i>minus</i> 8000h (- 
  32,768). Positive values are represented by exactly the same digits as their 
  numbers for 0000h through 7FFFh. A <i>minus</i> 7FFFh, however, is represented 
  by the Hex digits <b><font face="Courier New, Courier, mono" size="5">8001</font></b>, 
  and a <i>minus</i> 1h (-1) is represented by the Hex digits <b><font face="Courier New, Courier, mono" size="5">FFFF</font></b>. 
  Thus, the output of DEBUG after entering "h 4 fffc" would be a <i>zero</i> 
  and an 8, because <b><font face="Courier New, Courier, mono" size="5">FFFC</font></b> 
  represents a <i>minus</i> 4h (-4) and <b><font face="Courier New, Courier, mono">4 
  -</font></b> (<b><font face="Courier New, Courier, mono">-4</font></b>) = <b><font face="Courier New, Courier, mono">8</font></b>. 
  &nbsp;Examples:</font></p>
<pre><font size="4">   -<b>h 4 fffc</b>    -<b>h 100 123</b>    -<b>h 7fff 8000</b>
   0000 0008    0223  FFDD    FFFF FFFF
   -            -             -</font></pre>
<font face="Arial" size="4">Notice that the difference between 100h and 123h is 
<font face="Courier New, Courier, mono"> <font size="5"> <b>FFDD</b></font></font>; 
what does that represent? To find the numerical value of a Two's Complement number, 
first invert every bit (or find its logical inverse); that would be <font face="Courier New, Courier, mono"><b>0022</b></font>, 
then <b>add 1</b>. So, this represents a <i><b>negative</b></i><b> 23</b>h. Both 
the <b>sum</b> and the <b>difference</b> of 7FFFh and 8000h are a <b>negative 
1</b> (or <b><font face="Courier New, Courier, mono" size="5">FFFF</font></b>). 
You can, of course, think of the <b>sums</b> as having nothing to do with a Two's 
Complement notation; thus 7FFFh + 8000h = FFFFh (32,767 + 32,768 = 65,535). This 
will even hold true for the differences<i> <b>if </b>the second value is less 
than the first</i>. But as soon as the difference produces a negative number, 
it must be represented in Two's Complement.<br><br></font> 
<pre><b><a href="#TOC">Back to TOC</a></b>

<hr><a name="D"></a>
<font size="5"><b><font color="blue">   Dump:</font>  D  [range]
          D  [address]  [length]</b></font></pre>
<p><font face="Arial" size="4">&nbsp; &nbsp; Displays the contents of a block 
  of memory. The Memory locations near the beginning of Segment <b><font face="Courier New, Courier, mono" size="5">C000</font></b> 
  (even under Windows 2000/XP) should display information about the kind of video 
  card installed on your PC. This first example shows we have a Matrox card in 
  this system.<br>
  <br>
  Examples:</font></p>
<pre>-<b>d c000:0010</b>
C000:0010 24 12 FF FF 00 00 00 00-60 00 00 00 00 20 49 42  $.......`.... <b>IB</b>
C000:0020 4D 20 43 4F 4D 50 41 54-49 42 4C 45 20 4D 41 54  <b>M COMPATIBLE MAT</b>
C000:0030 52 4F 58 2F 4D 47 41 2D-47 31 30 30 20 56 47 41  <b>ROX/MGA-G100 VGA</b>
C000:0040 2F 56 42 45 20 42 49 4F-53 20 28 56 31 2E 32 20  <b>/VBE BIOS (V1.2</b>
C000:0050 29 00 87 DB 87 DB 87 DB-87 DB 87 DB 87 DB 87 DB  <b>)</b>...............
C000:0060 50 43 49 52 2B 10 01 10-00 00 18 00 00 00 00 03  PCIR+...........
C000:0070 40 00 12 10 00 80 00 00-38 37 34 2D 32 00 FF FF  @.......874-2...
C000:0080 E8 26 56 8B D8 E8 C6 56-74 22 8C C8 3D 00 C0 74  .&amp;V....Vt"..=..t
-</pre>

<pre>-<b>d 100 133</b>
xxxx:0100 EB 24 0D 0A 54 68 69 73-20 69 73 20 6D 79 20 66  .$..This is my f
xxxx:0110 69 72 73 74 20 44 45 42-55 47 20 70 72 6F 67 72  irst DEBUG progr
xxxx:0120 61 6D 21 0D 0A 24 31 C0-B4 09 BA 02 01 CD 21 B8  am!..$1.......!.
xxxx:0130 4C 00 CD 21                                      L..!
-</pre>
<font face="Arial" size="4">That last example is from our code under the <a href="#A"><b>A</b>ssemble</a> 
command. We could just as easily have used the<font face="Courier New"><b> length 
</b></font>option as seen below; where the '<font face="Courier New"><b>l24</b></font>' 
means a length of only 24 bytes (always in hexadecimal remember!). That's 36 in 
decimal:</font> 
<pre>-<b>d 102 l24</b>
xxxx:0100       0D 0A 54 68 69 73-20 69 73 20 6D 79 20 66    ..This is my f
xxxx:0110 69 72 73 74 20 44 45 42-55 47 20 70 72 6F 67 72  irst DEBUG progr
xxxx:0120 61 6D 21 0D 0A 24                                am!..$
-<b>

<a href="#TOC">Back to TOC</a>

<hr><a name="S"></a>
<font size="5"><font color="blue">  Search:</font>  S  range  list
</font></b></pre><font face="Arial" size="4">&nbsp; &nbsp; Searches within a 
range of addresses for a pattern of one or more byte values given in a list. 
The list can be comprised of numbers <i>or character strings enclosed by 
matching single or double quote marks.</i> 
Examples:</font><pre>-<b>s fe00:0 ffff "BIOS"</b>
FE00:<span style="background-color: rgb(204, 255, 255);">0021</span>
FE00:<span style="background-color: rgb(255, 255, 0);">006F</span>

-<b>d fe00:0</b>
FE00:0000 41 77 61 72 64 20 53 6F-66 74 77 61 72 65 49 42  Award SoftwareIB
FE00:0010 4D 20 43 4F 4D 50 41 54-49 42 4C 45 20 34 38 36  M COMPATIBLE 486
FE00:0020 20 42 49 4F 53 20 43 4F-50 59 52 49 47 48 54 20   <span style="background-color: rgb(204, 255, 255);">BIOS</span> COPYRIGHT
FE00:0030 41 77 61 72 64 20 53 6F-66 74 77 61 72 65 20 49  Award Software I
FE00:0040 6E 63 2E 6F 66 74 77 61-72 65 20 49 6E 63 2E 20  nc.oftware Inc.
FE00:0050 41 77 03 0C 04 01 01 6F-66 74 77 E9 12 14 20 43  Aw.....oftw... C
FE00:0060 1B 41 77 61 72 64 20 4D-6F 64 75 6C 61 72 20 42  .Award Modular <span style="background-color: rgb(255, 255, 0);">B</span>
FE00:0070 49 4F 53 20 76 34 2E 35-31 50 47 00 DB 32 EC 33  <span style="background-color: rgb(255, 255, 0);">IOS</span> v4.51PG..2.3

-<b>s 0:0 dff 'A20'</b>
0000:<span style="background-color: rgb(255, 204, 255);">0C42</span>

-<b>d 0:c40</b>
0000:0C40 0D 0A 41 32 30 20 68 61-72 64 77 61 72 65 20 65  ..<span style="background-color: rgb(255, 204, 255);">A20</span> hardware e
0000:0C50 72 72 6F 72 2E 20 20 43-6F 6E 74 61 63 74 20 74  rror.  Contact t
0000:0C60 65 63 68 6E 69 63 61 6C-20 73 75 70 70 6F 72 74  echnical support
0000:0C70 20 74 6F 20 69 64 65 6E-74 69 66 79 20 74 68 65   to identify the
0000:0C80 20 70 72 6F 62 6C 65 6D-2E 0D 0A 24 1A 00 BA F6   problem...$....

-<b>0:0 dff <span style="">43 4f 4d</span></b>
0000:0774
0000:07C2
0000:07D4
0000:07E6

-<b>d 0:770</b>
0000:0770 7A 02 A6 02 <span style="background-color: rgb(204, 255, 255);">43 4F 4D</span> 31-20 20 20 20 8E 00 70 00  z...<span style="background-color: rgb(255, 255, 0);">COM</span>1    ..p.
0000:0780 C0 A0 7A 02 91 02 4C 50-54 31 20 20 20 20 A0 00  ..z...LPT1    ..
0000:0790 70 00 C0 A0 7A 02 98 02-4C 50 54 32 20 20 20 20  p...z...LPT2
0000:07A0 2D 01 70 00 C0 A0 7A 02-9F 02 4C 50 54 33 20 20  -.p...z...LPT3
0000:07B0 20 20 11 EA 27 27 3F FD-CA 00 70 00 00 80 7A 02    ..''?...p...z.
0000:07C0 AC 02 <span style="background-color: rgb(204, 255, 255);">43 4F 4D</span> 32 20 20-20 20 DC 00 70 00 00 80  ..<span style="background-color: rgb(255, 255, 0);">COM</span>2    ..p...
0000:07D0 7A 02 B2 02 <span style="background-color: rgb(204, 255, 255);">43 4F 4D</span> 33-20 20 20 20 00 00 6B 03  z...<span style="background-color: rgb(255, 255, 0);">COM</span>3    ..k.
0000:07E0 00 80 7A 02 B8 02 <span style="background-color: rgb(204, 255, 255);">43 4F-4D</span> 34 20 20 20 20 E8 D2  ..z...<span style="background-color: rgb(255, 255, 0);">COM</span>4    ..


<b><a href="#TOC">Back to TOC</a>

<hr><a name="C"></a>
<font size="5"><font color="blue">Compare:</font>  C  range  address
</font></b></pre>
<font face="Arial" size="4">&nbsp; &nbsp; Compares two blocks of
memory. If there are no differences, then DEBUG simply displays another
prompt (-). Here's an example of what happens when there <i>are</i> differences:</font>
<pre>     -<b>c 140 148 340</b>
     127D:0143  30  6D  127D:0343
     127D:0146  10  63  127D:0346
     127D:0148  49  30  127D:0348</pre>
<font face="Arial" size="4">The bytes at locations 140 through 148 are being compared 
to those at 340 (through 348, <i>implied</i>); the bytes are displayed side by 
side for those which are different (with their exact locations, including the 
segment, on either side of them). </font> 
<pre><b>

<a href="#TOC">Back to TOC</a>

<hr><a name="F"></a>
<font size="5"><font color="blue">   Fill:</font>  F  range  list
</font></b></pre><font face="Arial" size="4">&nbsp; &nbsp; This command can 
also be used to <i>clear</i> large areas of Memory as well as <i>filling</i> 
smaller areas with a continuously repeating phrase or single byte. Examples:
</font><pre>-<b>f 100 12f 'BUFFER'</b>
-<b>d 100 12f</b>
xxxx:0100  42 55 46 46 45 52 42 55-46 46 45 52 42 55 46 46 BUFFERBUFFERBUFF
xxxx:0110  45 52 42 55 46 46 45 52-42 55 46 46 45 52 42 55 ERBUFFERBUFFERBU
xxxx:0120  46 46 45 52 42 55 46 46-45 52 42 55 46 46 45 52 FFERBUFFERBUFFER
   
-<b>f 0 ffff 0</b></pre><font face="Arial" size="4">&nbsp; This last 
example fills <i>all</i> of the assigned Segment with bytes of zeros ( which 
could also be thought of as <i>clearing</i> &nbsp;the whole Segment ). I use 
this command whenever I want to be sure that the bytes I'm looking at are 
those I'm concerned about and not just random bits of code lost in memory!
<br>
If you want to examine a file from disk in a 'clean' Segment, then you would 
first have to start DEBUG without the filename on the command line, <i>clear 
the Segment</i> using -f 0 ffff 0, and then finally load the file with the 
<a href="#N">Name (n)</a> and <a href="#L">Load (L)</a> 
commands.</font>
<pre><b><a href="#TOC">Back to TOC</a>

<hr><a name="E"></a>
<font size="5"><font color="blue">  Enter:</font>  E  address  [list]
</font></b></pre><font face="Arial" size="4">&nbsp; &nbsp; Used to 
enter data or instructions (as <i>machine code</i>) directly into Memory 
locations.<br>&nbsp; &nbsp; Example: First we'll change a single byte at 
location <font face="Verdana">CS:<b>FFCB</b></font> from whatever it was 
before to <font face="Verdana">
<b>D2</b></font></font><font size="4"></font><pre><font size="4">   -<b>e ffcb d2</b></font></pre><font size="4"><font face="Arial">The next two examples show that either single(') or 
double(") quote marks are acceptable for entering ASCII data. By 
allowing both forms, you can include the other type of quote mark within 
your entry string:</font></font><pre><font size="4">   -<b>e 200 'An "ASCII-Z string" is always followed by '
</b>   -<b>e 22a "a zero-byte ('00h')." 00</b></font></pre><font size="4"><font face="Arial">Now let's examine a string of 14 hex bytes entered into Memory at 
location CS:0100 and 
following:</font></font><pre><font size="4">   -<b>e 100 31 C0 B4 09 BA 0E 01 CD 21 B8 4C 00 CD 21</b></font></pre><font size="4"><font face="Arial">This is actually machine code for a program that 
will display whatever it finds at location CS:010E until it encounters a 
byte of 24h (a '$' sign).
<a name="PLAY"><br><br>
</a>Here's something a bit more interesting for you to try out: It's essentially 
the same program, but the data includes all of the bytes from 00h through FFh; 
except for 24h which was placed at the end of the last line. The DEBUG prompt 
'-' is purposely left out here so you can copy and paste the whole block all at 
once into DEBUG using a DOS-Window (You'll find <a href="http://www.geocities.com/thestarman3/DOS/DOSinWIN.html" target="diw">Help 
on using DOS-Window controls here</a>): </font> </font>
<pre><b>e 100 31 C0 B4 09 BA 0E 01 CD 21 B8 4C 00 CD 21 0D 0A 0D 0A
e 112 00 01 02 03 04 05 06 07 08 09 20 0B 0C 20 0E 0F 10 11
e 124 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F 20 21 22 23
e 136 20 25 26 27 28 29 2A 2B 2C 2D 2E 2F 30 31 32 33 34 35
e 148 36 37 38 39 3A 3B 3C 3D 3E 3F 0D 0A 0D 0A 40 41 42 43
e 15a 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F 50 51 52 53 54 55
e 16c 56 57 58 59 5A 5B 5C 5D 5E 5F 60 61 62 63 64 65 66 67
e 17e 68 69 6A 6B 6C 6D 6E 6F 70 71 72 73 74 75 76 77 78 79
e 190 7A 7B 7C 7D 7E 7F 0D 0A 0D 0A 80 81 82 83 84 85 86 87
e 1a2 88 89 8A 8B 8C 8D 8E 8F 90 91 92 93 94 95 96 97 98 99
e 1b4 9A 9B 9C 9D 9E 9F a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 aA aB
e 1c6 aC aD aE aF b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 bA bB bC bD
e 1d8 bE bF 0D 0A 0D 0A c0 c1 c2 c3 c4 c5 c6 c7 c8 c9 cA cB
e 1ea cC cD cE cF d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 dA dB dC dD
e 1fc dE dF e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 eA eB eC eD eE eF
e 20e f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 fA fB fC fD fE fF 0D 0A
e 220 0D 0A 24</b></pre><font face="Arial" size="4">The bytes <b>0D</b>h and <b>0A</b>h produce a Carriage 
Return and Linefeed on the display, so they were replaced by a <b>20</b>h (a 
space) in the listing above. The <b>24</b>h byte was, of course, moved to 
the end of the listing and its original location also turned into a space. 
A blank line was placed at the beginning and after every 64 bytes in the 
listing using the sequence '0D 0A 0D 0A.' So, we should see four separate 
lines of 64 characters each (a few of those being blank spaces in the first 
line of course) when the program is run, right? Start DEBUG in a DOS-Window, 
copy and paste the lines above into DEBUG at the '-' prompt, then enter the 
following command:
</font><pre><font size="5">     <b>g =100</b></font>    <b>( 'g' followed by a SPACE, then '=100')</b></pre>
<p><font face="Arial" size="4">This will run (see <a href="#G"> Go command</a>) the program 
  in DEBUG... displaying the lines we mentioned and another stating: "Program 
  terminated normally" <b>[ </b>If possible, do NOT close the DOS-Window 
  or exit DEBUG as we'll be making a 'patch' to this code later <b>]</b>. If you 
  were surprised to find more than four spaces on the first line, or that there 
  appear to be some missing characters at the end of that line, then you might 
  want to study about the Control Characters at the beginning of an ASCII chart. 
  You'll also need to learn about Interrupts and what effect different BIOS and 
  DOS Video Functions have on how the ASCII Characters are displayed.</font></p>
<p><font face="Arial" size="4">OK, I'll save you the time and tell you what happened: First, 
  the Zero byte displays as a blank space here. The <b>07</b>h byte sounds a BEEP 
  (but does not display anything), <b>08</b>h performs a BACKSPACE (erasing the 
  06h byte character) and <b>09</b>h is a TAB -- which may jump up to eight columns 
  to the right before reaching the next 'Tab Stop.' But since it just happens 
  to begin in column seven, it only moves one column to the right where our program 
  places the blank space we substituted for <b>0A</b>h. Lastly, for some reason, 
  when using Function 09 of INT 21 ("Display a string of characters until 
  a '$' sign is encountered"), the ESC character (<b>1B</b>h; 27 decimal) 
  doesn't display or do anything either. So, upon reaching the end of the first 
  line, it appears as if five of the characters were never displayed. <br>
  <br>
  If you enter the following two lines into DEBUG ( with more blank-space substitutions 
  inserted ) and run the program again, you'll see all of the displayable characters 
  output on the first line in their correct positions:</font> </p>
<pre><b>e 112 00 01 02 03 04 05 06 20 20 20 20 0B 0C 20
e 120 0E 0F 10 11 12 13 14 15 16 17 18 19 1A 20</b></pre><font face="Arial" size="4">All four rows should come out even now, including the 
last one, because the <b>FF</b>h (255 decimal) displays as a blank space!
You can prove this by inserting another byte such as 2Eh (a period '.') 
right after the FFh byte. Since DEBUG has <b>no</b> 'Insert' command, here's 
another 'patch' for you which effectively <i>moves</i> the remaining program 
bytes up one location:<br><font face="Courier"><b>e 21e 2e 0d 0a 0d 0a 24
</b></font><br>
Here's how the program output should look after <i>patching</i> it :<br>
<br><center><img src="debug2_files/dEASCII.gif" height="211" width="556"></center>
<br>
You can save this program to your hard drive, by first giving it a path and 
filename (such as, C:\TEMP\ASCIIDSP.COM; see <a href="#N">'N' Name 
command</a>) and writing the bytes (see <a href="#W">'W' Write command</a>) 
to a file like 
this:<br></font>
<pre><font size="4">   -<b>n c:\temp\asciidsp.com</b>
   -<b>rcx</b>
   CX0000
   :<b>124</b>       <font face="Tahoma">[ Program Length = 223h - 100h + 1 = 124h ]</font>
   -<b>w</b>
</font>
<b><a href="#TOC">Back to TOC</a>

<hr><a name="G"></a>
<font size="5"><font color="blue">     Go:</font>  G  [=address]  [<u>addresses</u>]
</font></b></pre><font face="Arial" size="4">&nbsp; &nbsp; Go is used to run 
a program and set <i><u>breakpoints</u></i> in the program's code.
<br><br>
As we saw in an Example for the ENTER command, the '=address' option is used 
to tell DEBUG a starting location. If you use 'g' all by itself, execution 
will begin at whatever location is pointed to by the CS:IP registers. 
Optional <i>breakpoints</i> ( meaning the program will HALT before executing 
the code at any of these locations) <b>of up to any ten addresses</b> may be 
set by simply listing them on the command line.
<br><br><b>Requirements:</b> Breakpoints can only be set 
at an address containing the first byte of a valid <b>8088/8086 Opcode</b>. 
So don't be surprised if picking some arbitrary address never halts the 
program; especially if you're trying to DEBUG a program containing opcodes 
DEBUG can't understand (that's anything 'requiring' a CPU above an 
8088/8086)!<br><br>
<b>CAUTION:</b> DEBUG replaces the original instructions of any listed 
breakpoint addresses with <b>CC</b>h (an INT 3). The instructions at these 
locations are restored to their originals ONLY if one of the breakpoints is 
encountered... If DEBUG does not HALT on any breakpoint, then all your 
breakpoints are still enabled! So, don't ever save the code as is, unless 
you're sure that DEBUG has hit one of your breakpoints! ( Saving to a backup 
copy <i>before using breakpoints</i> is often a better way. 
)</font><pre><b>

<a href="#TOC">Back to TOC</a>

<hr size="3"><a name="A"></a>
<font size="5"><font color="blue">Assemble:</font>  A  [address]</font></b></pre>
<font face="Arial" size="4">
 Creates machine executable code in memory beginning at CS:0100 (or the
 specified address) from the 8086/8088 (and 8087) Assembly Language
 instructions which are entered. Although no Macro instructions nor labels
 are recognized, you can use the <i>pseudo-instructions</i> 'DB' and 'DW'
 (so you can use the DB opcode to enter ASCII data like this: &nbsp;DB
 &nbsp; 'This is a string',0D,0A ).<br>
 The 'A' command remembers the last location where any data was assembled,
 so successive 'A' commands (when no address is specified) will always begin
 at the next address in the chain of assembled instructions. This aspect of
 the command is similar to the Dump command which remembers the location of
 its last dump (if no new address is specified).<br><br>
 The assembly process will stop <b><i>after</i></b> you ENTER an empty line.
<br><br>
 Example (you enter the characters in bold type):</font><pre>      -<b>a</b>
      xxxx:0100 <b>jmp 126</b>
      xxxx:0102 <b>db 0d,0a,'This is my first DEBUG program!'</b>
      xxxx:0123 <b>db 0d,0a,'$'</b>
      xxxx:0126 <b>xor ax,ax</b>
      xxxx:0128 <b>mov ah,9</b>
      xxxx:012A <b>mov dx,102</b>
      xxxx:012D <b>int 21</b>
      xxxx:012F <b>mov ax,4c</b>
      xxxx:0132 <b>int 21</b>
      xxxx:0134
      -<b>g =100</b>

      This is my first DEBUG program!

      Program terminated normally
      -

</pre><font face="Verdana" size="4">NOTE: You can <i>pipe</i> simple 
8086/8088 Assembly Language scripts into DEBUG (which can even include a 
semi-colon ';' followed by comments on any of its lines!).
<ul><li>DEBUG uses the convention of enclosing operands which refer to 
Memory locations in square brackets '[ ]' (as opposed to an immediate value 
as an operand).</li>
<br><br>
<li>DEBUG may require you to explicitly tell it whether or not an operand 
refers to a <i>word</i> or <i>byte</i> in Memory! In such cases, the data 
type must be stated using the prefixes 'WORD PTR' or 'BYTE PTR'</li>
<br><br>
<li>For all 8087 opcodes, the WAIT or FWAIT prefix must be explicitly 
specified.</li></ul>
</font><pre><b><a href="#TOC">Back to TOC</a>

<hr><a name="U"></a>
<font size="5"><font color="blue"><i>Un</i>assemble:</font>  U  [range]
</font></b></pre><font face="Arial" size="4">&nbsp; <b><i>Disassembles</i>
</b> machine instructions into 8086 Assembly code. <b>Without the optional 
[range]</b>, it uses <b>Offset 100</b> as its starting point, disassembles 
about 32 bytes and then remembers the next byte it should start with if the 
command is used again. ( The word 'about' was used above, because it may 
be necessary to finish with an odd-number of bytes greater than 32, depending 
upon the last type of instruction DEBUG has to disassemble. )<br><br>
&nbsp; &nbsp; &nbsp;<b>NOTE:</b> The user must decide whether the bytes that 
DEBUG disassembles are all 8086 <b>instructions</b>, just <b>data</b> or any 
of the newer x86 instructions (such as those for the 80286, 80386 on up to 
the lastest CPU from Intel; which are all beyond the ability of DEBUG to 
understand)!</font><pre><font size="4"><b>   Example:

   </b>-<b>u 126 133</b>
   xxxx:0126 31C0          XOR     AX,AX
   xxxx:0128 B409          MOV     AH,09
   xxxx:012A BA0201        MOV     DX,0102
   xxxx:012D CD21          INT     21
   xxxx:012F B84C00        MOV     AX,004C
   xxxx:0132 CD21          INT     21
   -</font><b>
   

<a href="#TOC">Back to TOC</a>

<hr><a name="I"></a>
<font size="5"><font color="blue">  Input:</font>  I  port
</font></b></pre>
<p><font face="Arial" size="4">The use of <font face="Verdana, Arial, Helvetica, sans-serif">I</font>/O 
  commands while running Windows&#8482;9x/Me is <i>just plain</i> unreliable!</font> 
  <font face="Arial" size="4">This is especially true when trying to directly 
  access hard disks! Under Win NT/2000/XP, the <font face="Verdana">I</font>/O 
  commands are only an <b><i>emulation</i></b>; so don't trust them. Though the 
  example below still works under Win2000/XP, it's most likely using some WinAPI 
  code to show what's in the Windows clock area; <i>not</i> directly from an RTC 
  chip.</font></p>
<p><font face="Arial" size="4">Long ago (when DOS was the only OS for PCs), there 
  were dozens of <b>BASIC</b> programs that used <font face="Verdana">I</font>/O 
  commands for handling tasks through parallel and serial ports (e.g., to change 
  the font used by a printer or values in a modem's control registers). Under 
  real DOS, they can still be used for direct communications with keyboards or 
  a floppy drive's control chips along with many other hardware devices.<br>
  &nbsp; &nbsp; Here's an example of how to read the hours and minutes from a 
  computer's "real time clock" (RTC):</font></p>
<pre><font face="Courier New" size="4">    -<b>o 70 04</b>  &lt;-- <font face="Arial">Check the <b>hours</b>.</font>
    -<b>i 71</b>
    18  &lt;----- <font face="Arial">18 hours (or 6 p.m.)</font>
    -<b>o 70 02</b>  &lt;-- <font face="Arial">Check the <b>minutes</b>.</font>
    -<b>i 71</b>
    52  &lt;----- <font face="Arial">52 minutes</font></font></pre>
<font face="Arial" size="4">The first space isn't necessary under most versions 
of DEBUG; so you can try to get away with just "o70" and "i71" 
instead. Here's a page of more complex examples dealing with <a href="http://www.geocities.com/thestarman3/asm/debug/ATAscript.htm" target="ATA">hard 
drives and the ATA commands for reading info directly from a disk controller</a>!</font> 
<pre><b><a href="#TOC">Back to TOC</a>

<hr><a name="O"></a>
<font size="5"><font color="blue">  Output:</font>  O  port  byte
</font></b></pre>
<p><font face="Arial" size="4">&nbsp; &nbsp; See comments under the<b><font size="5"><font color="blue"> 
  <font face="Courier New"><a href="#I">Input</a></font></font></font></b><font size="5"><font face="Arial" size="4"> 
  command.</font></font></font> </p>
<pre><b><a href="#TOC">Back to TOC</a>

<hr><a name="L"></a>
<font size="5"><font color="blue">   Load:</font>
L [address] [drive] [firstsector] [number]<br>&nbsp;&nbsp;&nbsp;<i>or program!</i><font face="Arial, Helvetica, sans-serif" size="4"> (See the <a href="#N">N command</a> for more on this)</font> 
</font></b></pre>
<p><font face="Arial" size="4">&nbsp; &nbsp; This command will LOAD the selected 
  number of sectors from any disk's Logical Drive under the control of MS-DOS 
  or Windows into Memory. The <b>address</b> is the location in Memory the data 
  will be copied to (use only 4 hex digits to keep it within the memory allocated 
  to DEBUG), the <b>drive</b> number is mapped as: 0=A:, 1=B:, 2=C:, etc., <b>firstsector</b> 
  counts from ZERO to the largest sector in the volume <i>and finally</i> <b>number</b> 
  specifies <b>in hexadecimal</b> the<i> <b>total </b></i><b>number</b> of sectors 
  that will be copied into Memory (so a floppy disk with 0 through 2,879 sectors 
  would be: 0 through <b><font face="Courier New, Courier, mono" size="5">B3F</font></b> 
  in Hex).</font><font face="Arial" size="4"><br>
  </font></p>
<p><font face="Arial" size="4">&nbsp; &nbsp; The terms 'Volume' or 'Logical Drive' 
  used in the definition above mean that you can <b><i>not</i></b> use the 'L' 
  command to load or examine the <b>MBR</b>, or any other sectors outside of the 
  Primary Volumes or Logical Drive Letters assigned by DOS or Windows!&nbsp;For 
  example (under Windows&#8482; 9x/ME), if you enter the command: &nbsp; <font face="Courier New"><b>L 
  100 2 0 1</b></font> &nbsp; in DEBUG, instead of seeing the very first sector 
  on that hard disk (the MBR), you'll see the first sector of the Boot Record 
  for the Logical drive C: instead (the first partition that can accessed by a 
  compatible MS-DOS or Windows OS). This and the following comments about diskettes, 
  show that DEBUG has always been quite limited compared to a good disk editor 
  or the UNIX 'dd' program.<br>
  </font></p>
<p><font face="Arial" size="4">Load can still be useful in examining Floppy Disks 
  <i>even under</i> Windows&#8482; 2000/XP, <b><i>but (unfortunately), only if 
  the disk can be read by MS-DOS or Windows.</i></b> Once again, this shows how 
  limited DEBUG is compared to any utility that can view the <i>raw data</i> on 
  either a hard drive or diskette.</font></p>
<p><font face="Arial" size="4">Unlike hard disks, the very first sector on a floppy 
  disk is an OS Boot sector. Here's what you might see from a Logical disk sector 
  and some <a href="#D"><b>d</b><i>umps</i></a> from a couple floppy disks. <br>
  <br>
  Examples:</font></p>
<pre>-<b>l 100 2 0 1</b>   [ the <b>C:</b> drive. ]
-<b>d 100 10f</b>
xxxx:0100  EB 58 90 4D 53 57 49 4E-34 2E 31 00 02 08 20 00 .X.MSWIN4.1... .
-<b>d 280 2ff</b>
xxxx:0280  01 27 0D 0A 49 6E 76 61-6C 69 64 20 73 79 73 74 .'..Invalid syst
xxxx:0290  65 6D 20 64 69 73 6B FF-0D 0A 44 69 73 6B 20 49 em disk...Disk I
xxxx:02A0  2F 4F 20 65 72 72 6F 72-FF 0D 0A 52 65 70 6C 61 /O error...Repla
xxxx:02B0  63 65 20 74 68 65 20 64-69 73 6B 2C 20 61 6E 64 ce the disk, and
xxxx:02C0  20 74 68 65 6E 20 70 72-65 73 73 20 61 6E 79 20 then press any
xxxx:02D0  6B 65 79 0D 0A 00 00 00-49 4F 20 20 20 20 20 20 key.....IO
xxxx:02E0  53 59 53 4D 53 44 4F 53-20 20 20 53 59 53 7E 01 SYSMSDOS   SYS~.
xxxx:02F0  00 57 49 4E 42 4F 4F 54-20 53 59 53 00 00 55 AA .WINBOOT SYS..U.
-
-<b>l 100 0 0 1</b>   [ a floppy in the <bb>A: drive. ]
-<b>d 100 13d</b>
xxxx:0100  EB 3C 90 29 47 38 71 33-49 48 43 00 02 01 01 00 .&lt;.)G8q3<span style="background-color: rgb(255, 221, 221);">IHC</span>.....
xxxx:0110  02 E0 00 40 0B F0 09 00-12 00 02 00 00 00 00 00 ...@............
xxxx:0120  00 00 00 00 00 00 29 40-16 D8 13 4E 4F 20 4E 41 ......)@...NO NA
xxxx:0130  4D 45 20 20 20 20 46 41-54 31 32 20 20 20       ME    FAT12   
-
-<b>l 100 0 0 1</b>   [ a different floppyy in the <b>A:</b> drive. ]
-<b>d 100 13d</b>
xxxx:0100  EB 3C 90 53 59 53 4C 49-4E 55 58 00 02 01 01 00 .&lt;.SYSLINUX.....
xxxx:0110  02 E0 00 40 0B F0 09 00-12 00 02 00 00 00 00 00 ...@............
xxxx:0120  00 00 00 00 00 00 29 7E-CF 55 3C 20 20 20 20 20 ......)~.U&lt;
xxxx:0130  20 20 20 20 20 20 46 41-54 31 32 20 20 20             FAT12   
-
-<b>d 2d0 2ff</b>
xxxx:02D0  42 3B 16 1A 7C 72 03 40-31 D2 29 F1 EB A7 42 6F B;..|r.@1.)...Bo
xxxx:02E0  6F 74 20 66 61 69 6C 65-64 0D 0A 00 00 00 00 4C ot failed......L
xxxx:02F0  44 4C 49 4E 55 58 20 53-59 53 F4 3C 82 3A 55 AA DLINUX SYS.&lt;.:U.
</bb></pre>
<p><font face="Arial" size="4">Note that the Linux Boot disk above (note the word: 
  SYSLINUX) is the kind formatted as an MS-DOS diskette and not with a true Linux 
  file system. If it had been formatted with some other kind of file system, or 
  had a faulty boot sector, then MS-DEBUG would not be able to read it! Instead 
  you'd see that old "<font face="Courier New">General failure reading drive 
  A / Abort, Retry, Fail?</font>" error message! And when you had finally 
  cleared away that error message, you'd be greeted by DEBUG's "<font face="Courier New">Disk error reading drive A</font>" error message. This 
  makes DEBUG almost worthless as far as trying to fix an error in a floppy disk's 
  boot sector! However, if you keep a binary copy of a <i>good</i> floppy disk 
  Boot Sector somewhere, you <i>could</i> use DEBUG to overwrite whatever's on 
  a faulty floppy disk's first sector (see <a href="#W">Write command</a>). <b>But</b> 
  if you really want to see what's in such a Boot sector (that keeps DEBUG from 
  recognizing it as valid), you'll need to use a disk editor such as Symantec's 
  Norton DiskEdit (in <b><i>Physical</i></b> disk Mode only).</font></p>
<p><font face="Arial" size="4">&nbsp; &nbsp; NOTE: Just because a floppy disk 
  can't be read by DOS or opened in DEBUG does NOT necessarily mean it's defective. 
  It might simply have been formatted with a different OS (such as Linux) and 
  could easily boot-up on its own; a very good reason for labeling your disks! 
  (CAUTION: Never try booting your system with a disk you're not 100% sure of; 
  unless you disconnect all hard disks and don't have any flash BIOS, because 
  it might contain a nasty <i>boot virus!</i><a name="IHC"> )</a> <br>
  &nbsp; [ <font size="3">Many floppy disks have the letters &nbsp; <font face="Verdana"><b>IHC</b></font> 
  &nbsp; in their OEM ID field. What kind of OEM Name is that? None. Someone at 
  Microsoft decided that this was where they'd place a new pseudo-random type 
  of identification to make sure that any information cached by '<b>Windows 9x</b>' 
  from one disk wouldn't be mixed up with info from a different one if you <i>swapped 
  disks</i>. The whole string begins with <b>five pseudo-random hex bytes</b>, 
  and always ends with the characters <b>IHC</b>. <i>All</i> floppy diskettes 
  that are <b>not</b> write-protected will have any original OEM ID overwritten. 
  Once Windows has written this string, it will remain the same for any future 
  disk reads or writes. However, performing even a <i>quick</i> format under Windows, 
  will change the five hex bytes every time. <br>
  &nbsp; &nbsp; Some have concluded that the characters '<b>IHC</b>' are the first 
  three letters of the word "Chicago" <i>in reverse order</i>, since 
  <b><i>Chicago</i></b> was the 'code name' for Windows 95&#8482; before it was 
  ever released (it would have appeared as ' OGACIHC' on the hypothetical disk). 
  Although certainly a possibility, I have no proof of that. Due to my interest 
  in some very old Greek Manuscripts, I still can't help seeing the 3 characters 
  'IHC' as an Iota, Eta and <i>old style</i> Sigma since this combination of letters 
  was often used as an abbreviation for the Greek word IHSUS. Just another one 
  of those coincidences of life. <br>
  &nbsp; &nbsp; <b>REMEMBER:</b> If you really want to preserve all of the contents 
  of an important diskette, you can't even perform a simple Directory read under 
  a Windows OS, UNLESS it is 'write-protected' <b><i>and</i></b> you know the 
  drive's write-protect system is functioning correctly!</font> ]</font></p>
<p>&nbsp; </p>
<pre><b><a href="#TOC">Back to TOC</a>

<hr><a name="M"></a>
<font size="5"><font color="blue">   Move:</font>  M  range  address
</font></b></pre><font face="Arial" size="4">&nbsp; &nbsp; This command 
should really be called: COPY (not Move) as it actually <i>copies</i> all 
the bytes from within the specified <b>range</b> to a new <b>address</b>.
<br><br>&nbsp; &nbsp; Examples:</font>
<pre><font size="4">  <b>1)</b>   -<b>m 7c00 7cff 600</b></font></pre>
<font face="Arial" size="4">Copies all the bytes between Offset 7C00 and 
7CFF (inclusive) to Offset 0600 and following...</font>
<pre><font size="4">  <b>2)</b>   -<b>m 100 2ff 70</b></font></pre>
<font face="Arial" size="4">This second 
example shows that it's very easy to <b><i>overwrite</i></b> most of the 
source you're copying from using the <i>Move</i> command. Apparently, DEBUG 
stores the source bytes elsewhere before writing them; otherwise, this 
example would cause a problem when it started overwriting what it hadn't 
copied yet! This copies the 512 bytes between Offsets 100h and 2FFh 
(inclusive) to <b>Offset 0070</b> overwriting the first 368 bytes in the 
process.</font><pre><b><a href="#TOC">Back to TOC</a>

<hr><a name="N"></a>
<font size="5"><font color="blue">   Name:</font>  N  [pathname]  [arglist]
</font></b></pre>
<p><font face="Arial" size="4">&nbsp; &nbsp; This command can be used to load 
  files into DEBUG's Memory <i>after</i> you have started the program, but it's 
  main function is to create a new file under control of the Operating System 
  which DEBUG can <a href="#W">WRITE</a> data to.<br>
  &nbsp; &nbsp; Normally, when you want to 'debug' a file, you'd start DEBUG with 
  a command like this: &nbsp; <font face="Courier New">C:\WINDOWS&gt;<b>debug 
  test.com</b></font> . &nbsp; But it's also possible to load a file into DEBUG's 
  Memory from within DEBUG itself by using the 'N' command <i>and then the</i> 
  <a href="#L">'L' command</a> <b>(</b>with <b>no</b> parameters<b>)</b> like 
  this:<br>
  <font face="Courier New">&nbsp; &nbsp; -<b>n c:\temp\test.com</b><br>
  &nbsp; &nbsp; -<b>l</b></font><br>
  which will load the file test.com into DEBUG's Memory starting at location CS:0100 
  <b>(</b>you cannot specify any other location when using the L command like 
  this!<b>)</b>.</font></p>
<p><font face="Arial" size="4">&nbsp; &nbsp; The 'N' command makes it quite easy 
  to save data or an Assembly program created in DEBUG to a file on your hard 
  drive!<br>
  For example, these commands (<b>in bold</b>; along with DEBUG's reponses): <br>
  </font></p>
<font face="Arial" size="4"> 
<ul>
  <font face="Courier">-<b>n c:\temp\doswinok.com</b><br>
  -<b>a 100</b><br>
  <i>cs</i>:0100 <b>jmp 138</b><br>
  <i>cs</i>:0102 <b>db 0d,0a,"It's OK to run this "</b><br>
  <i>cs</i>:0118 <b>db "program under DOS or Windows!"</b><br>
  <i>cs</i>:0135 <b>db 0d,0a,24</b><br>
  <i>cs</i>:0138 <b>mov dx,102</b><br>
  <i>cs</i>:013B <b>mov ah,9</b><br>
  <i>cs</i>:013D <b>int 21</b><br>
  <i>cs</i>:013F <b>mov ax,4c01</b><br>
  <i>cs</i>:0142 <b>int 21</b><br>
  <i>cs</i>:0144<br>
  -<b>rcx</b><br>
  CX 0000<br>
  :<b>44</b><br>
  -<b>w</b><br>
  Writing 00044 bytes &nbsp; <font face="Georgia">[ 68 bytes in decimal ]</font><br>
  -<b>q</b></font> 
</ul>
</font>
<p><font face="Arial" size="4">will create a 68-byte file called <font face="Verdana">DOSWINOK.COM</font> 
  in the C:\TEMP folder; <i>even</i> when running DEBUG in a DOS-window. The file 
  names, however, are still limited to DOS's <b>eight</b> characters <i>plus</i> 
  <b>three</b> for the extension (an <i>8.3 filename</i> as it's often called)!</font></p>
<p><font face="Arial" size="4"><i>Homework:</i> Follow the steps above to <a href="#A">Assemble</a> 
  and save this program under DEBUG, then use DEBUG to <b><i>debug it!</i></b> 
  Use the <a href="#P">P(roceed) command</a> to <b>step through</b> most of the 
  instructions, <b><i>since </i></b> this will keep you from accidentally <i>stepping 
  into</i> an <b>INT</b>(errupt) instruction! If you ever do use the T(race) command 
  on an INT, you'll end up inside nests of <b>BIOS</b> routines which often <i>crashes</i> 
  DEBUG!</font> </p>
<pre>
<b><a href="#TOC">Back to TOC</a>

<hr><a name="R"></a>
<font size="5"><font color="blue">Register:</font>  R  [register]</font>
</b></pre><font face="Arial" size="4">&nbsp; &nbsp; Entering ' r ' all by 
itself will display <i>all</i> of the 8086 register's contents <i>and</i> 
the next instruction which the IP register points to in both machine code 
and an unassembled (Assembly Language) form. For example, if you start 
DEBUG in a Windows 95B DOS-box with the command line:<br> &nbsp; &nbsp; 
<font face="Courier New">&gt;<b>debug c:\windows\command\choice.com</b><br>
</font> and then enter an ' r ' at the first DEBUG prompt, DEBUG will 
display someting similar to this:</font><font size="3"><pre>AX=0000  BX=0000  CX=1437  DX=0000  SP=FFFE  BP=0000  SI=0000  DI=0000
DS=0ED8  ES=0ED8  SS=0ED8  CS=0ED8  IP=0100   NV UP EI PL NZ NA PO NC
0ED8:0100 E90E01        JMP     0211
</pre></font><font face="Arial" size="4">For an explanation of the names of 
the registers (AX, BX, CX, etc. and the <i>Flag symbols:</i> NV UP EI PL NZ 
NA PO NC), see the Appendix (<a href="http://www.geocities.com/thestarman3/asm/debug/8086REGs.htm#REGS" target="REGS">The 8086 CPU Registers</a>). 
The last line shows that the next CPU instruction (actually the <i>first</i> 
in this case) to be executed, begins at memory location 100 hex (the Offset) 
in Segment ED8 hex (0ED8:0100) and that the Hex bytes E90E01 represent the 
actual binary machine code of the CPU instruction (JMP 0211 in Assembly 
language) that <i>would be executed by DEBUG</i> if you entered a 
<a href="#T">Trace (<b>t</b>)</a> or <a href="#P">Proceed (<b>p</b>)</a> 
command.<br><br>If you enter the ' r ' followed by the abbreviation for an 
8086 register, such as: ' rcx ', then DEBUG will display only the contents 
of that register followed by a line with a colon symbol (:) on which you can 
enter a hex number to change the contents of that register. If you simply 
press the ENTER key, the contents remain the same. For example:
<br><br>
<font face="Courier New">&nbsp; &nbsp; -<font color="blue"><b>rcx</b></font>
<br>&nbsp; &nbsp; CX 0100<br>&nbsp; &nbsp; :<font color="blue"><b>273</b>
</font></font><br><br>means that the Register command was used to change the 
contents of the CX register from 0100 to 0273. The command ' rcx ' could be 
used again to verify that the change had indeed taken place. If you type the 
letter <b>f</b> after an r: ' rf ', this commands DEBUG to display all of 
the FLAG register bits with a prompt on the same line which allows you to 
change any or none of the individual flag bits. For example, here's how you 
would display the flags and change just the Zero Flag bit from being cleared 
(a 0 bit) to being set (a 1 bit):
<br><br>
<font face="Courier New">&nbsp; &nbsp; -<font color="blue"><b>rf</b></font>
<br>&nbsp; &nbsp; NV UP EI PL NZ NA PO NC &nbsp;-<font color="blue"><b>zr
</b></font><br>&nbsp; &nbsp; -<font color="blue"><b>rf</b></font><br>&nbsp; 
&nbsp; NV UP EI PL ZR NA PO NC &nbsp;-<br>&nbsp; &nbsp; -</font><br>
As you can see above the Zero Flag was changed from NZ (cleared) to ZR (set). 
See the Appendix <a href="http://www.geocities.com/thestarman3/asm/debug/8086REGs.htm#FLAGS" target="REGS">The FLAGS Register</a> below for an 
explanation of all the Flag 
abbreviations.</font><pre><b><a href="#TOC">Back to TOC</a>

<hr><a name="T"></a>
<font size="5"><font color="blue">   Trace:</font>  T  [=address]  [number]
</font></b></pre><font face="Arial" size="4">&nbsp; &nbsp; The T command is 
used to trace (step through) CPU instructions one at a time. If you enter 
the T command all by itself, it will step through only ONE instruction 
beginning at the location specified by your CS:IP registers, halt program 
execution and then display all the CPU registers plus an unassembled version 
of the next instruction to be executed; this is the 'default' mode of the 
TRACE command. Say, however, you wanted DEBUG to trace and execute seven 
instructions beginning at address CS:0205; to do so, you would enter:<br><br>
<font face="Courier"> &nbsp; &nbsp; -<b>t =205 7</b></font><br><br>
Remember that the value for the number of instructions to execute must be 
given in hexadecimal just as all other values used in DEUBG. (Since the T 
command uses the "hardware trace mode" of the CPU, it's possible 
to step through instructions in a ROM - Read Only Memory - chip.)
</font><pre><b>

<a href="#TOC">Back to TOC</a>

<hr><a name="P"></a>
<font size="5"><font color="blue"> Proceed:</font>  P  [=address]  [number]
</font></b></pre><font face="Arial" size="4">&nbsp; &nbsp; <i>Proceed</i> 
acts exactly the same as Debug's <a href="#T">T (Trace) command</a> for most 
types of instructions... EXCEPT: <i>Proceed</i> will immediately execute ALL 
the instructions (rather than stepping through each one) inside any 
Subroutine CALL, a LOOP, a REPeated string instruction or any software 
INTerrupts. This means that you do not have to single-step through any of 
the code contained in a Subroutine or INT call if you use the Proceed (P) 
command.<br>&nbsp; &nbsp; This means <i>Proceed</i> will be the command you 
use most often to debug programs, and Trace will only be used to step into a 
Subroutine or possibly check the logic of the first few iterations of a LOOP 
or REP instruction.</font><pre><b><a href="#TOC">Back to TOC</a>

<hr><a name="W"></a>
<font size="5"><font color="red">Write:</font>
W [address] [drive] [firstsector] [number]</font></b></pre>

<center><table bgcolor="pink" border="1" width="97%"><tbody><tr><td>
<table border="0"><tbody><tr><td width="10">&nbsp;</td><td>
<center><font face="Comic Sans MS" size="6">W A R N I N G</font></center>
<font face="Arial" size="4">Do NOT <i>experiment</i> with the <b>W - 
write</b> command in DEBUG. It can be used effectively to create new files 
on your hard drive, but only if you use it properly. Trying to write 
directly to a sector on a hard disk would very RARELY be considered proper 
use of this command!</font></td></tr></tbody></table></td></tr></tbody></table></center>
<ul>
<font color="red" face="Arial" size="5">Trying to write directly to a hard 
disk using sector numbers will most likely result in loss of data or even 
a corrupted hard drive!</font>
</ul>
<font face="Arial" size="4"> &nbsp; &nbsp; The WRITE (W) command is often used 
to save a program to your hard disk from within DEBUG. But the only safe way to 
do so, especially under Windows, is by allowing the OS to decide where to physically 
create that file on the disk. This is done by first using the <a href="#N">Name 
(N) command</a> to set up an <i>optional path</i> and <b>filename</b> for the 
new file (or to overwrite one that already exists). DEBUG will automatically begin 
saving program or data bytes from <font face="Verdana"><b>Offset 0100</b></font> 
of the 64 KiB Segment that the OS allocated for it. The only other requirement 
is to set the size of the file you wish to write by placing the total number of 
bytes in the<a name="bxbk"></a> <b>combined <font face="Verdana">BX</font></b> 
and <b><font face="Verdana">CX</font> registers<a href="#bxcx"><font color="red" face="Verdana" size="5">*</font></a></b> 
before executing the WRITE command. The <a href="#R">Register command</a> is used 
to change the value in <b>the CX register</b> in the following example from our 
own <a href="http://www.geocities.com/thestarman3/asm/mbr/Mymbr.zip">MyMBR Batch/Debug Script Program</a>.<br>
<br>
<b>EXAMPLE:</b><br>
After creating and running a small program inside of DEBUG which copies the Master 
Boot Record (<b>MBR</b>) to Offset <b>0000</b>h through <b>01FF</b>h, these DEBUG 
commands save the MBR to a file on the hard disk: 
</font><pre><font face="Arial" size="4"><font size="4">   -<b>n mymbr.bin</b>
   -<b>rcx</b>
   CX 0001
   :<b>200</b>
   -<b>w 0</b>
   Writing 00200 bytes   <font face="Georgia">[ 512 bytes in decimal ]</font>
   -
</font></font></pre>
<p><font face="Arial" size="4"> <font face="Arial" size="4">The BX register had 
  already been set to zero by a previous instruction, so the CX register was simply 
  set to 200 and the WRITE command executed with <b>an address of 0</b> (if no 
  address is used, the Write command starts saving bytes at <b>Offset 100</b>). 
  <br>
  <br>
  The WRITE command <i>can</i>, however, be used in a <i>relatively safe</i> manner 
  with Floppy disks. For example, you could use the <a href="#L">Load (L) command</a>:<br>
  <font face="Courier New"> &nbsp; &nbsp; <b>l 7c00 0 0 1</b></font><br>
  to load the first sector of an MS-DOS or Windows floppy disk into DEBUG's memory 
  at location 7C00, change some of the code and/or messages (if you know how to 
  do so) and then use the 'W' command:<br>
  <font face="Courier New"> &nbsp; &nbsp; <b>w 7c00 0 0 1</b></font><br>
  to write the changes back to the floppy disk's first sector.</font></font></p>
<p><font face="Arial" size="4">___________________<br>
  <a name="bxcx"></a><b><font color="#ff0000" face="Verdana" size="5">*</font></b><font face="Times">Although 
  the BX and CX registers are often referenced in books on Assembly as <font face="Verdana"><b>BX:CX</b> 
  </font> when they discuss the <b>write</b> command, NOTE that these registers 
  are <b>not</b> being used like Segment:Offset pairs in this case! They are a 
  true combination of higher and lower bytes which form a 'double word' for a 
  <b><i>theoretical total</i></b> of <b>four Gigabytes</b> (<b>FFFF FFFF</b>h 
  = 4,294,967,295 bytes) that could be written to a file! I'm not sure if this 
  has always been true of DEBUG, but under DOS 7.1 (sometimes called Windows 98), 
  I've been able to load image files of several hundreds of KB and then write 
  the whole file to a new location!<br>
  &nbsp; &nbsp; For example, if I load a <b>360 KB</b> image file into DEBUG at 
  a DOS prompt, then check the registers, <font face="Verdana"><b>BX</b></font> 
  will equal <font face="Verdana"><b>0005</b></font> and <font face="Verdana"><b>CX</b></font> will 
  contain <font face="Verdana"><b>A000</b></font>. The major problem here though 
  is the fact that DEBUG uses <b>CONVENTIONAL MEMORY</b>, so trying to load an 
  image file greater than about 400KB or so is bound to elicit an "<b>Insufficient 
  Memory</b>" error<b>!</b><br>
  <b>[</b> </font></font><b><a href="#bxbk">click here to go back to text above</a></b> 
  <font face="Times" size="4"><b>]</b></font><br>
  <br>
  <font size="4"><a href="#TOC">Back to TOC</a></font> <br>
  <br>
</p>
<p>&nbsp; </p>
<table bgcolor="#ccffcc" border="1" width="97%">
  <tbody><tr> 
    <td> 
      <table border="0">
        <tbody><tr> 
          <td width="10">&nbsp;</td>
          <td>
            <center>
              <font face="Comic Sans MS" size="6">N O T E :</font>
            </center>
            <font face="Arial" size="4">You may have missed this page on: <a href="http://www.geocities.com/thestarman3/asm/debug/DOSstub.htm" target="stub">The 
            Windows&#8482; DOS <i>Stub</i> Program</a>.<br>
            There are more examples for many DEBUG <i>commands</i> in these <b>x86</b> 
            tutorial pages:<br>
            <a href="http://www.geocities.com/thestarman3/asm/fire/Fire.html" target="fire">FIRE.com : Some MS-DEBUG 
            Tricks</a> and <a href="http://www.geocities.com/thestarman3/asm/eicar/eicarcom.html" target="ei">The EICAR 
            Standard AV Test Program</a> .<br>
            </font></td>
        </tr>
      </tbody></table>
    </td>
  </tr>
</tbody></table>
<p>&nbsp; </p>
<hr><br><br><br>
<font face="Verdana" size="5"><i>Last Update:</i> <b>October 23, 2004</b>. (23.10.2004)</font> 
<hr><center><br>
  <img src="debug2_files/left.gif" height="14" width="33"> <a href="http://www.geocities.com/thestarman3/asm/debug/debug.htm"><b><font size="6"> 
  A Guide to DEBUG (Page One)</font></b></a><br>
  <br><img src="debug2_files/left.gif" height="14" width="33"> 
<a href="http://www.geocities.com/thestarman3/asm/index.html"><b><font size="6">The Starman's Realm Assembly 
Page</font></b></a></center><br><br><br><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p>
<!-- text below generated by server. PLEASE REMOVE -->
<script language="JavaScript" src="debug2_files/div.js"></script><div style="visibility: visible; left: 827px;" id="y_gc_div_adcntr" class="y_gcss_ovrtr_cntr"><div style="visibility: visible; left: 827px;" id="y_gc_div_mast" class="y_gcss_ovrtr_msthd"><a href="http://geocities.yahoo.com/"><img src="debug2_files/geo_mast_small2.gif" alt="Yahoo! GeoCities" border="0" height="15" hspace="4" vspace="4" width="141"></a><img src="debug2_files/space.gif" height="1" width="7"><a href="javascript:;" onmousedown="maximizeAu('y_gc_div_au1')" ;=""><img src="debug2_files/geo_ad_dwn_widg2.gif" border="0" height="13" hspace="2" vspace="6" width="14"></a><a href="javascript:;" onclick="closeAu('y_gc_div_adcntr')" ;=""><img src="debug2_files/geo_ad_close_widg2.gif" border="0" height="13" hspace="2" vspace="6" width="14"></a></div><div style="left: 827px; visibility: hidden;" id="y_gc_div_au1" class="y_gcss_ovrtr_au"><a href="http://geocities.yahoo.com/"><img src="debug2_files/geo_mast_small2.gif" alt="Yahoo! GeoCities" border="0" height="15" hspace="4" vspace="4" width="141"></a><img src="debug2_files/space.gif" height="1" width="7"><a href="javascript:;" onmousedown="minimizeAu('y_gc_div_au1')" ;=""><img src="debug2_files/geo_ad_up_widg2.gif" border="0" height="13" hspace="2" vspace="6" width="14"></a><a href="javascript:;" onclick="closeAu('y_gc_div_adcntr')" ;=""><img src="debug2_files/geo_ad_close_widg2.gif" border="0" height="13" hspace="2" vspace="6" width="14"></a><div class="y_gcss_ovrtr_au_cbox"><iframe border="0" marginwidth="0" marginheight="0" hspace="10" vspace="0" src="debug2_files/h.htm" frameborder="0" height="440" scrolling="no" width="175"></iframe></div></div></div><script language="JavaScript" src="debug2_files/mc.js"></script><script language="JavaScript" src="debug2_files/geov2.js"></script><script language="javascript">geovisit();</script><img src="debug2_files/visit.gif" border="0">
<noscript><img src="http://visit.webhosting.yahoo.com/visit.gif?us1107136269" alt="setstats" border="0" width="1" height="1"></noscript>
<img src="debug2_files/serv.gif" alt="1" height="1" width="1">
</body></html>