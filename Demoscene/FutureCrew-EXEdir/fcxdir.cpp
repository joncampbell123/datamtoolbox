
#include <stdio.h>
#include <string.h>
#include "common/Types.h"
#include "Demoscene/FutureCrew-EXEdir/fcxdir.h"

// these are copies of the first N bytes of the executable code that exists at the
// entry point of the Future Crew demo .EXE files (meaning that the MS-DOS EXE
// header and all fluff that might exist at the very beginning is considered irrelevant).
//
// this is done to ensure that we are in fact looking at a Future Crew product because
// if we assume so our only other check is the last DWORD in the entire file, which
// could appear to be valid in any other EXE in the world but cause this code to enumerate
// garbage.
//
// NOTE: Several other FC demos including Second Unreal also have this entry point code,
//       but not the directory structure this program looks for.

static unsigned char common_anti_debugger_code[4] = {0xBC,0x74,0x00,0xC3};

/* Common code in these demos. */
static unsigned char common_initialization_0x91[] = {
// Generated by Softx86dbg, hand commented by Jonathan Campbell
//
// CS = SS
// SP = 0x76
// DS = ES = PSP segment
/*1586:0091*/  0xE4,0x21,                    // IN AL,21h                   <- read the PIC mask IRQs 0-7
/*1586:0093*/  0x2E,0xA2,0x09,0x00,          // CS: MOV [0009h],AL          <- store at CS:9, obliterating the entry point
/*1586:0097*/  0xB0,0xFF,                    // MOV AL,FFh                  <- mask off all interrupts
/*1586:0099*/  0xE6,0x21,                    // OUT 21h,AL
/*1586:009B*/  0xFA,                         // CLI                         <- disable interrupts
/*1586:009C*/  0x2E,0x8C,0x1E,0x8F,0x00,     // CS: MOV [008Fh],DS          <- store the PSP segment given to us by DOS
/*1586:00A1*/  0x1F,                         // POP DS                      <- pops from SS:0x76 which is 0x0000, SP = 0x78
/*1586:00A2*/  0xFC,                         // CLD                         <- DF=0
/*1586:00A3*/  0xB4,0x08,                    // MOV AH,08h                  <- Get Drive Parameters
/*1586:00A5*/  0xB2,0x80,                    // MOV DL,80h                  <- Hard drive #1
/*1586:00A7*/  0xB6,0x00,                    // MOV DH,00h                  <- Programmer paranoia?
/*1586:00A9*/  0xCD,0x13,                    // INT 13h                     <- reset hard disk
/*1586:00AB*/  0x80,0xFE,0x00,               // CMP DH,0000h
/*1586:00AE*/  0x74,0x0A,                    // JZ 00BAh                    <- if no heads (no drive) goto CS:0xBA
/*1586:00B0*/  0x2E,0x89,0x0E,0x84,0x00,     // CS: MOV [0084h],CX          <- store disk geometry at CS:0x84
/*1586:00B5*/  0x2E,0x89,0x16,0x86,0x00,     // CS: MOV [0086h],DX          <- and CS:0x86
/*1586:00BA*/  0xB4,0x0F,                    // MOV AH,0Fh
/*1586:00BC*/  0xCD,0x10,                    // INT 10h                     <- what is the current BIOS video mode?
/*1586:00BE*/  0x3C,0x07,                    // CMP AL,07h                  <- if monochrome then skip to CS:0xC9
/*1586:00C0*/  0x74,0x07,                    // JZ 00C9h
/*1586:00C2*/  0x2E,0xC7,0x06,0x88,0x00,0x34,0x1A,// CS: MOV [0088h],1A34h  <- segment is (0x1A34 + 0x9DCC) = 0xB800
/*1586:00C9*/  0x2E,0x81,0x06,0x88,0x00,0xCC,0x9D,// CS: ADD [0088h],9DCCh  <- if 0xC2 was skipped, segment is (0x1234 + 0x9DCC) = 0xB000
// here, the code attempts to detect 286/386 protected mode
/*1586:00D0*/  0x54,                         // PUSH SP                     <- 80286+ check, overwriting CS:0x76 in the process
/*1586:00D1*/  0x58,                         // POP AX                      <- on pre-286 machines this would give AX != SP
/*1586:00D2*/  0x3B,0xC4,                    // CMP AX,SP                   <- are they the same?
/*1586:00D4*/  0x74,0x04,                    // JZ 00DAh                    <- if so, it's a 286 or higher
/*1586:00D6*/  0xBD,0x00,0x00,               // MOV BP,0000h                <- BP=0 and return
/*1586:00D9*/  0xC3,                         // RET
// at this point we know it's a 286 or higher
/*1586:00DA*/  0x0F,0x01,0xE1,               // SMSW CX                     <- load Machine Status Word into CX
/*1586:00DD*/  0xD1,0xC9,                    // ROR CX,1                    <- check for protected mode
/*1586:00DF*/  0x73,0xF5,                    // JNC 00D6h                   <- if none then goto 0xD6 to set BP=0
/*1586:00E1*/  0xBD,0x01,0x00,               // MOV BP,0001h                <- BP=1 and return
/*1586:00E4*/  0xC3,                         // RET
// So by the end of this routine:
//
// CS:0x0009 WORD:         once the entry point, now contains the old interrupt mask
// CS:0x0074 WORD:         the magic word, which led us here
// CS:0x0076 WORD:         0x0000 until overwritten with the value of SP which is 0x78
// CS:0x0078 WORD:         the 2nd magic entry point, when this routine completes
// CS:0x007A WORD:         the 3rd magic entry point, when the 2nd entry point completes
// CS:0x007C WORD:         the 4th magic entry point, when the 3rd entry point completes
// CS:0x0084 BYTE:         maximum sector number of first hard drive
// CS:0x0085 BYTE:         low eight bits of maximum cylinder number of first hard drive
// CS:0x0086 BYTE:         number of drives
// CS:0x0087 BYTE:         maximum head number
// CS:0x0088 WORD:         segment of alphanumeric video RAM (initially 0x1234, ofuscated)
// CS:0x008F WORD:         PSP segment
//
// BP=1 if 286/386 protected mode was detected, 0 if not
};

/* code at the 2nd magic entry point */
static unsigned char common_initialization_0x133[] = {
// Generated by Softx86dbg, hand commented by Jonathan Campbell
//
// looks like some very ofuscated method of intercepting interrupt vectors 0 to 3
//
// CS = SS
// SP = 0x7A
// ES = PSP segment
// DS = 0x0000
// BP = CPU_Protected_Mode_Enabled ? 1 : 0
/*1586:0133*/  0x2E,0xC6,0x06,0x8A,0x00,0x62,// CS: MOV [008Ah],0062h             <- ?
/*1586:0139*/  0xBB,0x47,0x46,               // MOV BX,4647h                      <- BX=0x4647 == 'GF'
/*1586:013C*/  0xBE,0x23,0x01,               // MOV SI,0123h                      <- SI=0x0123
/*1586:013F*/  0x33,0xFF,                    // XOR DI,DI                         <- DI=0
/*1586:0141*/  0xB9,0x04,0x00,               // MOV CX,0004h                      <- CX=4
/*1586:0144*/  0xBA,0x4D,0x4A,               // MOV DX,4A4Dh                      <- DX=0x4A4D == 'MJ'
/*1586:0147*/  0x2E,0xC6,0x06,0x8B,0x00,0x43,// CS: MOV [008Bh],0043h             <- ?
// it runs through a table at CS:0x123 containing 0x0000:offset to it's own interrupt
// handlers for INT 0 thru 3. each entry is two WORDS, and is swapped with the real
// interrupt vector table so that when the loop is done the old vectors are stored here
// and this program's has INT 0 thru 3 hooked.
// begin loop {
/*1586:014D*/  0x2E,0xAD,                    // CS: LODSW                         <- AX = *SI, SI += 2
/*1586:014F*/  0x87,0x05,                    // XCHG [DI],AX                      <- exchange old offset with our new offset
/*1586:0151*/  0x2E,0x89,0x44,0xFE,          // CS: MOV [SI-2],AX
/*1586:0155*/  0x8C,0xC8,                    // MOV AX,CS                         <- exchange old segment with our segment
/*1586:0157*/  0x87,0x45,0x02,               // XCHG [DI+0002h],AX
/*1586:015A*/  0x2E,0x89,0x04,               // CS: MOV [SI],AX
/*1586:015D*/  0x83,0xC6,0x02,               // ADD SI,0002h                      <- SI += 2
/*1586:0160*/  0x83,0xC7,0x04,               // ADD DI,0004h                      <- DI += 4
/*1586:0163*/  0xE2,0xE8,                    // LOOP 014Dh
// } end loop
/*1586:0165*/  0x8B,0xFA,                    // MOV DI,DX
/*1586:0167*/  0xBA,0x8A,0x00,               // MOV DX,008Ah
/*1586:016A*/  0x8C,0xC8,                    // MOV AX,CS
/*1586:016C*/  0x8E,0xD8,                    // MOV DS,AX
/*1586:016E*/  0x8B,0xF3,                    // MOV SI,BX
/*1586:0170*/  0xB8,0x11,0x09,               // MOV AX,0911h
/*1586:0173*/  0xC3,                         // RET
// So by the end of this routine:
//
// interrupt vectors 0 thru 3 are hooked by this program:
//     INT 0x00: division by zero
//     INT 0x01: debug break
//     INT 0x02: NMI
//     INT 0x03: debug break
//
// by intercepting INT 3 it effectively disables all breakpoints in a debugger
//
// CS:0x0009 WORD:         once the entry point, now contains the old interrupt mask
// CS:0x0074 WORD:         the magic word, which led us here
// CS:0x0076 WORD:         0x0000 until overwritten with the value of SP which is 0x78
// CS:0x0078 WORD:         the 2nd magic entry point
// CS:0x007A WORD:         the 3rd magic entry point when this completes
// CS:0x007C WORD:         the 4th magic entry point, when the 3rd entry point completes
// CS:0x0084 BYTE:         maximum sector number of first hard drive
// CS:0x0085 BYTE:         low eight bits of maximum cylinder number of first hard drive
// CS:0x0086 BYTE:         number of drives
// CS:0x0087 BYTE:         maximum head number
// CS:0x0088 WORD:         segment of alphanumeric video RAM (initially 0x1234, ofuscated)
// CS:0x008A BYTE:         0x62
// CS:0x008B WORD:         0x43
// CS:0x008F WORD:         PSP segment
//
// BP=1 if 286/386 protected mode was detected, 0 if not
// AX=0x911
// DS=CS
// DI=0x4A4D
// DX=0x008A
// SI=0x4647
// SP=0x7A
};

/* code at the 3rd magic entry point */
static unsigned char common_initialization_0xE5[] = {
// Generated by Softx86dbg, hand commented by Jonathan Campbell
//
// it calls its own INT 3 handler, which in turn toggles ON the Trap Flag
// so that INT 1 occurs upon return (ick!)
//
// it also "decrypts" the 4th entry point
//
// SP = 0x7C
/*1586:00E5*/  0x2E,0xC6,0x06,0x0E,0x01,0x40,// CS: MOV [010Eh],0040h
/*1586:00EB*/  0xCC,                         // INT 3
/*1586:00EC*/  0xBB,0x78,0x01,               // MOV BX,0178h
/*1586:00EF*/  0xB8,0x27,0x5F,               // MOV AX,5F27h
/*1586:00F2*/  0xB9,0x8C,0x01,               // MOV CX,018Ch
/*1586:00F5*/  0x29,0x07,                    // SUB [BX],AX
/*1586:00F7*/  0x83,0xC3,0x02,               // ADD BX,0002h
/*1586:00FA*/  0x49,                         // DEC CX
/*1586:00FB*/  0x75,0xF8,                    // JNZ 00F5h
/*1586:00FD*/  0xC3,                         // RET
};

#ifdef NOT_INCLUDED
static unsigned char common_initialization_INT_3[] = {
// also of interest: the INT 1 AND INT 3 handler installed by the program
// What sick twisted mind came up with this?!?
// INT 1 begins here
/*1586:00FE*/  0xF9,                         // STC
// INT 3 begins here
/*1586:00FF*/  0x55,                         // PUSH BP                   <- save BP
/*1586:0100*/  0x8B,0xEC,                    // MOV BP,SP                 <- BP becomes SP
/*1586:0102*/  0x73,0x0E,                    // JNC 0112h                 <- jump if not carry (not INT 1)
// red herring { /* executed on INT 1. this doesn't really do anything, though it looks convincing */
/*1586:0104*/  0x53,                         // PUSH BX                   <- save BX
/*1586:0105*/  0x8B,0x5E,0x02,               // MOV BX,[BP+0002h]         <- BX = *(SS:BP+2)
/*1586:0108*/  0x2E,0x80,0x3F,0x49,          // CS: CMP [BX],0049h        <- compare *CS:BX to 0x49
/*1586:010C*/  0x75,0x01,                    // JNZ 010Fh                 <- if not equal then skip this:
/*1586:010E*/  0x43,                         // INC BX                    <- BX++
/*1586:010F*/  0x5B,                         // POP BX                    <- restore BX
// end red herring } /* BX is unchanged, BP is unchanged, flags are not saved on IRET */
// common exit:
/*1586:0110*/  0x5D,                         // POP BP                    <- restore BP
/*1586:0111*/  0xCF,                         // IRET                      <- return to caller
// XOR the last value on the stack with 0x100, then copy WORD from *0x1A4 to *0x7E
/*1586:0112*/  0x81,0x76,0x06,0x00,0x01,     // XOR [BP+0006h],0100h      <- *(SS:BP+6) ^= 0x100 (toggle TF in EFLAGS in INT frame)
/*1586:0117*/  0x2E,0x8B,0x2E,0xA4,0x01,     // CS: MOV BP,[01A4h]        <- BP = *(SS:0x1A4)
/*1586:011C*/  0x2E,0x89,0x2E,0x7E,0x00,     // CS: MOV [007Eh],BP        <- *(DS:0x7E) = BP
/*1586:0121*/  0xEB,0xED,                    // JMP 0110                  <- return to caller
};
#endif

// encrypted code at CS:0x178
static unsigned char common_initialization_0x178[16] = {0x55,0x00,0xB7,0x5F,0x57,0x02,0x34,0x5F,0xE6,0xF0,0x2D,0x17,0xC0,0xA3,0xE7,0xDE};

int FutureCrewEXEDirReader::file::Read(unsigned char *buf,int N)
{
	uint64 ofs;
	int sz,r;

	if (!parent->sf) return 0;
	if (offset >= item.size) return 0;
	sz = item.size - ((int)offset);
	if (N > sz) N = sz;
	ofs = offset + item.offset;
	if (parent->sf->Seek(ofs) != ofs) return 0;
	r = parent->sf->Read(buf,N);
	offset += r;
	return r;
}

int FutureCrewEXEDirReader::file::Write(unsigned char *buf,int N)
{
	return 0;
}

uint64 FutureCrewEXEDirReader::file::Seek(uint64 ofs)
{
	if (ofs > ((uint64)item.size)) ofs = (uint64)item.size;
	offset = ofs;
	return offset;
}

uint64 FutureCrewEXEDirReader::file::Tell()
{
	return (uint64)offset;
}

uint64 FutureCrewEXEDirReader::file::GetSize()
{
	return (uint64)item.size;
}

char* FutureCrewEXEDirReader::file::GetName()
{
	return (char*)item.name;
}

int FutureCrewEXEDirReader::ReadItem(int x,ITEM *i)
{
	unsigned char buf[24];
	int o;

	if (x < 0 || x >= numFiles) return -1;

	o = dirOffset + (x * 24);
	if (!sf) return -1;
	if (sf->Seek(o) != o) return -1;
	if (sf->Read(buf,24) < 24) return -1;

	memcpy(i->name,buf,16); i->name[16] = 0;
	i->offset = llei32(buf + 16);
	i->size = llei32(buf + 20);
	return 0;
}

int FutureCrewEXEDirReader::FindItem(ITEM *i,char *name)
{
	int x;

	for (x=0;x < numFiles;x++) {
		if (ReadItem(x,i) >= 0) {
			if (!strcmpi(name,(char*)i->name)) return 0;
		}
	}

	return -1;
}

FutureCrewEXEDirReader::file *FutureCrewEXEDirReader::GetFile(ITEM *i)
{
	FutureCrewEXEDirReader::file* n;

	n = new FutureCrewEXEDirReader::file;
	if (!n) return NULL;
	memcpy(&n->item,i,sizeof(FutureCrewEXEDirReader::ITEM));
	n->offset = 0;
	n->parent = this;
	return n;
}

FutureCrewEXEDirReader::FutureCrewEXEDirReader()
{
	entry_pt_ofs=0;
	entry_pt_cs=0;
	entry_pt_ip=0;
	sf = NULL;
}

void FutureCrewEXEDirReader::Assign(SomeFile *f)
{
	sf = f;
}

// all Future Crew demos that this code is concerned with are MS-DOS EXE files.
// this function's purpose is to make SURE that we're dealing with a valid .EXE that fits these demo files
int FutureCrewEXEDirReader::IsEXE()
{
	unsigned char buf[32];

	if (!sf) return -1;

/* none of these demos are large!
   this check also avoids having to use a 64-bit integer to hold the file size */
	if (sf->GetSize() >= ((uint64)0x10000000)) return -1;

	if (sf->Seek(0) != 0) return -1;
	if (sf->Read(buf,32) < 32) return -1;

// signature valid?
	if (memcmp(buf,"MZ",2)) return -1;

// make sure the "length of image mod 512" field is less than 512
	if (llei16(buf+2) >= 512) return -1;

// all demos in question have the standard 32-byte header.
	hdr_size = llei16(buf+8) * 16;
	if (hdr_size != 32) return -1;

// NONE of them have relocation tables.
	if (llei16(buf+6) != 0) return -1;

// make sure the length is valid
	resmem_length = (llei16(buf+4) * 512) + llei16(buf+2);
	fsize = (unsigned long)sf->GetSize();
	if ((hdr_size+resmem_length) > fsize) return -1;

// NOTE *[1]: Some EXE files I've seen have an initial CS:IP value that would
//            be considered valid in DOS mode but would totally screw up a
//            simple parser. In other words, they have funny entry points like
//            CS:IP = 0xFFFF:0x0010 which would be valid because
//            (0xFFFF << 4) + 0x10 == 0xFFFF0 + 0x10 == 0x100000. In 16-bit
//            real mode this would wrap back around to 0x00000 and therefore
//            point to the very beginning of the memory resident image anyway.

// copy down the entry point
	entry_pt_ip = llei16(buf+0x14);
	entry_pt_cs = llei16(buf+0x16);
	entry_pt_ofs = (((entry_pt_cs * 16) + entry_pt_ip) & 0xFFFFF) + hdr_size; // *[1]

// and the initial stack pointer
	entry_pt_ss = llei16(buf+0x0E);
	entry_pt_sp = llei16(buf+0x10);
	entry_pt_stackofs = (((entry_pt_ss * 16) + entry_pt_sp) & 0xFFFFF) + hdr_size; // *[1]

// sanity check for the entry point
	if (entry_pt_ofs >= (resmem_length + hdr_size)) return -1;

// because of the common code in all FC demos we were written for the
// exact value of the stack pointer is irrelevant (see IsFCProduct()).

// OK it checks out
	return 0;
}

int FutureCrewEXEDirReader::Check()
{
	unsigned char buf[4];
	uint64 filesize;

	numFiles = 0;
	dirOffset = 0;
	if (!sf) return -1;

	filesize = sf->GetSize();
	if (filesize < ((uint64)256)) return -1;
	if (sf->Seek(filesize-4) != (filesize-4)) return -1;
	if (sf->Read(buf,4) < 4) return -1;

	dirOffset = llei32(buf);
	if (dirOffset >= (filesize-4)) return -1;
	if (dirOffset < 64) return -1;
	if (sf->Seek(dirOffset) != dirOffset) return -1;
	dirOffset += 12;

// skip unknown value
	if (sf->Read(buf,4) < 4) return -1;

// number of files
	if (sf->Read(buf,4) < 4) return -1;
	numFiles = llei32(buf);

// what exactly is this?
	if (sf->Read(buf,4) < 4) return -1;

	return 0;
}

// assuming that IsEXE was called and that it is a valid EXE,
// check the entry point code and compare it against known executable binary.
int FutureCrewEXEDirReader::IsFCProduct()
{
	unsigned char buf[2048];
	unsigned long magic_entry;
	unsigned long magic_entry2;
	unsigned long magic_entry3;
	unsigned long magic_entry4;

	if (!sf) return -1;
	if (entry_pt_ofs == 0 || entry_pt_stackofs == 0) return -1;

// all demos in question have the same code at the entry point:
// xxxx:0006 BC7400        MOV     SP,0074
// xxxx:0009 C3            RET
//
// this means that ultimately only the inital stack segment matters (SS),
// since the offset (SP) is immediately changed.
	if (sf->Seek(entry_pt_ofs) != entry_pt_ofs) return -1;
	if (sf->Read(buf,4) < 4) return -1;
	if (memcmp(buf,common_anti_debugger_code,4)) return -1;

// OK now locate the magic value that is RETd to
	magic_entry = (entry_pt_ss * 16) + 0x74 + hdr_size;
	if (sf->Seek(magic_entry) != magic_entry) return -1;
	if (sf->Read(buf,2) < 2) return -1;
	magic_entry_ip = llei16(buf);
	magic_entry_ofs = (entry_pt_cs * 16) + magic_entry_ip + hdr_size;

// sanity checks for the value.
// obviously based on what we know the magic entry cannot reside within the code it just RETd from
	if ((entry_pt_ip >= 4 && magic_entry_ip >= (entry_pt_ip-4)) && (magic_entry_ip < (entry_pt_ip+4)))
		return -1;

// now compare the executable binary to known sequences
	if (sf->Seek(magic_entry_ofs) != magic_entry_ofs) return -1;
	if (sf->Read(buf,sizeof(common_initialization_0x91)) < sizeof(common_initialization_0x91)) return -1;
	if (memcmp(buf,common_initialization_0x91,sizeof(common_initialization_0x91))) return -1;

// locate the 2nd magic entry point
	magic_entry2 = (entry_pt_ss * 16) + 0x78 + hdr_size;
	if (sf->Seek(magic_entry2) != magic_entry2) return -1;
	if (sf->Read(buf,2) < 2) return -1;
	magic_entry_ip2 = llei16(buf);
	magic_entry_ofs2 = (entry_pt_cs * 16) + magic_entry_ip2 + hdr_size;

// now compare the executable binary to known sequences
	if (sf->Seek(magic_entry_ofs2) != magic_entry_ofs2) return -1;
	if (sf->Read(buf,sizeof(common_initialization_0x133)) < sizeof(common_initialization_0x133)) return -1;
	if (memcmp(buf,common_initialization_0x133,sizeof(common_initialization_0x133))) return -1;

// locate the 3rd magic entry point
	magic_entry3 = (entry_pt_ss * 16) + 0x7A + hdr_size;
	if (sf->Seek(magic_entry3) != magic_entry3) return -1;
	if (sf->Read(buf,2) < 2) return -1;
	magic_entry_ip3 = llei16(buf);
	magic_entry_ofs3 = (entry_pt_cs * 16) + magic_entry_ip3 + hdr_size;

// now compare the executable binary to known sequences
	if (sf->Seek(magic_entry_ofs3) != magic_entry_ofs3) return -1;
	if (sf->Read(buf,sizeof(common_initialization_0xE5)) < sizeof(common_initialization_0xE5)) return -1;
	if (memcmp(buf,common_initialization_0xE5,sizeof(common_initialization_0xE5))) return -1;

// locate the 4th magic entry point
	magic_entry4 = (entry_pt_ss * 16) + 0x7C + hdr_size;
	if (sf->Seek(magic_entry4) != magic_entry4) return -1;
	if (sf->Read(buf,2) < 2) return -1;
	magic_entry_ip4 = llei16(buf);
	if (magic_entry_ip4 != 0x178) return -1;
	magic_entry_ofs4 = (entry_pt_cs * 16) + magic_entry_ip4 + hdr_size;

// now compare the executable binary to known sequences
	if (sf->Seek(magic_entry_ofs4) != magic_entry_ofs4) return -1;
	if (sf->Read(buf,sizeof(common_initialization_0x178)) < sizeof(common_initialization_0x178)) return -1;
	if (memcmp(buf,common_initialization_0x178,sizeof(common_initialization_0x178))) return -1;

	return 0;
}
